using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using TagLib;

namespace if2ktool_gui
{
    // This is an experimental version of TagWriterWorker that writes tags in a ParallelFor.
	// While it does boost the performance significantly, it thrashes the disk usage,
	// and makes the code a lot more complicated than it needs to be.
    
	public static class TagWriterWorker
    {
        static BackgroundWorker worker;
        static Main mainForm;

        static TagWriterWorkerArgs args;
        static TagWriterWorkerArgs lastArgs;
		
        static bool isPaused;

        // Call  Reset() to pause, Set() to unpause
        static ManualResetEvent manualResetEvent;

        public static bool InProgress
        {
            get { return worker.IsBusy; }
        }

		public static bool Paused
        {
			get { return isPaused;  }
            set
            {
                isPaused = value;

                // Pause the worker
                if (value == true)
                    manualResetEvent.Reset();
                else if (value == false)
                    manualResetEvent.Set();
            }
        }

        public enum TagWriterReturnCode : byte
        {
            Success = 0,
            Unmapped = 1,
            UnsupportedFormat = 2,
            CorruptFile = 3,
            IOEError = 4,
            OtherError = 5,
        }

        public class TagWriterWorkerArgs
        {
            public EntryFilter filter;
            public bool filterNot;
            public bool skipDateAdded;
            public bool skipLastPlayed;
            public bool skipPlayCount;
            public bool skipRating;
            public bool removeTags;
            public IEnumerable<DataGridViewRow> rows;
        }

        // Static ctor
        static TagWriterWorker()
        {
            mainForm = (Main)Application.OpenForms["Main"];

            worker = new BackgroundWorker();
            worker.WorkerReportsProgress = true;
            worker.WorkerSupportsCancellation = true;
            worker.DoWork += worker_DoWork;
            worker.ProgressChanged += worker_ProgressChanged;
            worker.RunWorkerCompleted += worker_Completed;

            Console.CancelKeyPress += Console_CancelKeyPress;

            manualResetEvent = new ManualResetEvent(false);
        }

        private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)
        {
            StopWorker();
        }

        public static void StartWorker(TagWriterWorkerArgs args)
        {
            if (worker.IsBusy)
                Debug.LogError("Cannot start writing tags while already writing tags!");
            else
            {
                // Ensure the manualResetEvent is set (unpaused)
                Paused = false;

                mainForm.ShowProgress(true);
                worker.RunWorkerAsync(args);
            }
        }
        
        public static void StopWorker(bool force = false)
        {
            if (worker.IsBusy)
            {
                if (!force)
                {
                    // Stop processing while the MessageBox is showing
                    Paused = true;

                    // Ask the user if they want to cancel writing tags
                    if (MessageBox.Show("Do you want to cancel the current tag writing process?", "Cancel?", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.No)
                    {
                        // Resume processing
                        Paused = false;

                        return;
                    }
                }

                // Cancel the worker
                worker.CancelAsync();

                // Un-pause worker (so that the execution continues to exit)
                Paused = false;
            }
        }

        // Called on the main thread when the worker has reported it's progress
        // This updates the form to select the row with the currentRowIndex, setting the progress bar value and the status label text
        private static void worker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            var args = (ProgressArgs)e.UserState;
            mainForm.SetRowSelection(args.currentRowIndex, true);
            mainForm.SetProgress(args.processed, args.count, args.timeMs);
        }

        // Called on the main thread when the worker is complete, or is cancelled
        private static void worker_Completed(object sender, RunWorkerCompletedEventArgs e)
        {
            // Reset the "Processed" flag on all rows
            foreach (var entry in args.rows.Select(x => x.DataBoundItem).Cast<Entry>().Where(x => x.processed))
                entry.processed = false;

            // Check to see if the worker was cancelled.
            // If we weren't already removing/reverting tags, ask the user if they want to revert the changes that were made
            if (e.Cancelled && lastArgs != null && !lastArgs.removeTags)
            {
                Debug.Log("--- CANCELLED ---");

                if (MessageBox.Show("Do you want to revert changes made to files, and erase the playback statistics tags that have already been written to files?", "Revert", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.Yes)
                {
                    var args = lastArgs;
                    args.removeTags = true;

                    // Get subset of entries where the tags have already been written
                    args.rows = args.rows.Where(x => ((Entry)x.DataBoundItem).wroteTags);

                    // Start a new worker with the same args, but removeTags true
                    // Takes into account skip arguments too
                    StartWorker(args);

                    return;
                }
            }
			
            args = lastArgs = null;
            Console.CursorVisible = true;
            mainForm.ShowProgress(false);
        }

        private static void worker_DoWork(object sender, DoWorkEventArgs e)
        {
            args = (TagWriterWorkerArgs)e.Argument;

            // Assign args to static variable. This is mainly used for cancellation/reverting, to understand what files were targeted in the operation
            lastArgs = args;

            int processed = 0;
            int count = args.rows.Count();

            // Misc
            int success = 0;                // <- File was successfully written to
            int unmapped = 0;               // <- Entry didn't have a file mapped to it
            int unsupportedFormat = 0;      // <- File was of an unsupported format (UnsupportedFormatException)
            int corruptFile = 0;            // <- File was corrupted (CorruptFileException)
            int ioError = 0;                // <- Error occured while loading the file (IOException)
            int otherError = 0;             // <- Another exception occurred

            // Interval at which to report progress
            //const int progressReportInterval = 100;
            long progressReportCounter = 0;

            Debug.Log(string.Format("\nWriting tags for {0} files, using the following parameters:\nfilter:\t\t{1}\nskipDateAdded:\t{3}\nskipLastPlayed:\t{4}\nskipPlayCount:\t{5}\nskipRating:\t{6}\nremoveTags:\t{7}\n\nUse Ctrl-C to terminate", count, args.filter, args.filterNot, args.skipDateAdded, args.skipLastPlayed, args.skipPlayCount, args.skipRating, args.removeTags));

            // Exit here if we have nothing to process
            if (count == 0)
            {
                Debug.LogError("No entries to process!", true);
                return;
            }

            // Wait 3 seconds before starting
            if (Settings.Current.workerDelayStart)
            {
                for (int i = 0; i < 3; i++)
                {
                    Console.Write(".");
                    System.Threading.Thread.Sleep(1000);
                }
            }

            var sw = System.Diagnostics.Stopwatch.StartNew();
            Console.Write("\n\n");

            void ReportProgress(int rowIndex)
            {
                // Report progress to main thread to update DataGridView selection
                worker.ReportProgress(0, new ProgressArgs()
                {
                    processed = processed,
                    count = count,
                    timeMs = sw.ElapsedMilliseconds,
                    currentRowIndex = rowIndex,
                });
            }
			
            int lowestBreakIndex = 0;

            Resume:

            // Split the work into multiple parallel threads
            ParallelLoopResult parallelLoopResult = Parallel.ForEach(args.rows.Skip(lowestBreakIndex), (row, parallelLoopState) =>
            {
                // Firstly, do some processing stuffs that can only be done in the worker

                // Check if we should pause
                if (isPaused)
                {
                    // Breaking allows current parallel iterations to complete before stopping
                    parallelLoopState.Break();
                    return;
                }

                // Check if we should cancel
                if (worker.CancellationPending)
                {
                    e.Cancel = true;
                    parallelLoopState.Stop();
                    return;
                }

                // Check if we should report progress
                // Only report progress every <progressReportInterval> milliseconds
                if (Settings.Current.workerReportsProgress && sw.ElapsedMilliseconds - progressReportCounter > Settings.Current.workerReportProgressInterval)
                {
                    progressReportCounter = sw.ElapsedMilliseconds;
                    ReportProgress(row.Index);
                }

                // Fetch the DataBoundItem from the DataGridViewRow
                var entry = (Entry)row.DataBoundItem;

                // Check if the entry hasn't already been processed in this session
                // This may be the case if we paused previously
                if (!entry.processed)
                {
                    // Create a new DebugStack
                    // We're unable to log from a parallel for, as the logs would be out of sync - and wouldn't be clustered together
                    // So instead of logging normally, logging within a Parallel is done to a DebugStack, which essentially just collects the logs so that we can fire them all at once
                    var ds = new DebugStack();

                    // Write the tags for this Entry
                    var result = WriteTagsForRow(entry, ++processed, ds);

                    // Increment the error/success counter
                    switch (result)
                    {
                        case TagWriterReturnCode.Success: success++; break;
                        case TagWriterReturnCode.Unmapped: unmapped++; break;
                        case TagWriterReturnCode.UnsupportedFormat: unsupportedFormat++; break;
                        case TagWriterReturnCode.CorruptFile: corruptFile++; break;
                        case TagWriterReturnCode.IOEError: ioError++; break;
                        case TagWriterReturnCode.OtherError: otherError++; break;
                    }

                    // Set the processed flag on this entry to true
                    entry.processed = true;

                    // Log the DebugStack
                    ds.Push();
                }
            });

            // If the Parallel.ForEach was paused, isPaused will be set
            if (isPaused)
            {
                // Save the index of the lowest last item processed
                lowestBreakIndex = (int)parallelLoopResult.LowestBreakIteration;

                Debug.Log("--- PAUSED ---");
                sw.Stop();

                // WaitOne until resumed
                manualResetEvent.WaitOne();

				// Handle cancelling while paused
				if (worker.CancellationPending || e.Cancel)
                {
                    e.Cancel = true;
                    return;
                }
				else
                {
                    Debug.Log("--- RESUMED ---");
                    sw.Start();
                }

                // Jump back up to Resume
                goto Resume;
            }

            // Return if we cancelled
            if (e.Cancel)
                return;

            sw.Stop();

            // Do final ReportProgress
            ReportProgress(args.rows.Last().Index);

            string resultStr = string.Format("Took {0}ms ({1})\n {2} files were written to successfully\n {3} files could not be written to\n  {4} unsupported format\n  {5} corrupt\n  {6} IO errors\n  {7} unmapped\n  {8} other errors occurred", sw.ElapsedMilliseconds, TimeSpan.FromMilliseconds(sw.ElapsedMilliseconds).ToString("m\\:ss"), success, unsupportedFormat + corruptFile + ioError + unmapped + otherError, unsupportedFormat, corruptFile, ioError, unmapped, otherError);

            Debug.Log("Done! " + resultStr);
            MessageBox.Show(resultStr, "Done!", MessageBoxButtons.OK, MessageBoxIcon.Information);

            if (args.removeTags)
                Debug.Log("\n" + Consts.REMOVE_TAGS_FINISHED);
            else
                Debug.Log("\n" + Consts.WRITE_TAGS_FINISHED);
        }

        // --- Main Process Method ---
        private static TagWriterReturnCode WriteTagsForRow(Entry entry, int processed, DebugStack ds)
        {
            TagLib.File file;
            Debug.Log("#" + processed + " - " + entry.fileName);

            // Check if the entry is mapped to a file
            if (entry.isMapped == false)
            {
                ds.LogWarning(" -> Entry is not matched to file");
                return TagWriterReturnCode.Unmapped;
            }

            bool isRetry = false;

        Retry:

            // Create TagLib file representation, catch to see if the file is valid
            try
            {
                file = TagLib.File.Create(entry.mappedFilePath, isRetry ? ReadStyle.Average : ReadStyle.PictureLazy);
            }
            catch (UnsupportedFormatException)
            {
                ds.LogError(" -> File format with extension \"" + Path.GetExtension(entry.mappedFilePath) + "\" is unsupported");
                return TagWriterReturnCode.UnsupportedFormat;
            }
            catch (CorruptFileException corruptEx)
            {
                ds.LogError(" -> File appears corrupt!");
                return TagWriterReturnCode.CorruptFile;
            }
            catch (IOException ioex)
            {
                ds.LogError("\t-> An IO exception occured while loading the file \"" + entry.fileName + "\"");

                // Get the locking processes (if any)
                var lockingProcesses = FileLockUtility.GetProcessesLockingFile(entry.mappedFilePath);

                // Log locking processes
                if (lockingProcesses != null && lockingProcesses.Count > 0)
                    ds.LogError("\tThe file appears to be locked by the process(es): " +
                        string.Join(", ", lockingProcesses.Select(p => p.ProcessName).ToArray()));

                return TagWriterReturnCode.IOEError;
            }
            catch (Exception ex)
            {
                ds.LogError("\t-> An error occured while loading the file \"" + entry.fileName + "\"\n\t" + ex.Message);
                return TagWriterReturnCode.OtherError;
            }

            // If we're in remove move
            if (args.removeTags)
            {
                if (!args.skipDateAdded)
                    RemoveCustomTag(file, Consts.TAG_DATE_ADDED, ds);
                if (!args.skipLastPlayed)
                    RemoveCustomTag(file, Consts.TAG_LAST_PLAYED, ds);
                if (!args.skipPlayCount)
                    RemoveCustomTag(file, Consts.TAG_PLAY_COUNT, ds);
                if (!args.skipRating)
                    RemoveRating(file, ds);

                entry.wroteTags = false;
            }

            // If we're in writing mode
            else
            {
                // Date Added
                if (!args.skipDateAdded && entry.dateAdded != DateTime.MinValue)
                {
                    // Create LDAP/Windows File Time long
                    long dateAddedWinTime = entry.dateAdded.ToFileTime();

                    if (Settings.Current.fullLogging)
                        ds.Log(string.Format("\tWriting {0}: {1}\n\t-> Converted to {3} (or {2})", Consts.PLIST_KEY_DATE_ADDED, entry.dateAdded.ToString("o", System.Globalization.CultureInfo.InvariantCulture), entry.dateAdded.ToString(), dateAddedWinTime));

                    // Write the tag
                    WriteCustomTag(file, Consts.TAG_DATE_ADDED, dateAddedWinTime.ToString(), ds);
                }

                // Last Played
                if (!args.skipLastPlayed && entry.lastPlayed != DateTime.MinValue)
                {
                    // Create LDAP/Windows File Time long
                    long lastPlayedWinTime = entry.lastPlayed.ToFileTime();

                    if (Settings.Current.fullLogging)
                        ds.Log(string.Format("\tWriting {0}: {1}\n\t-> Converted to {3} (or {2})", Consts.PLIST_KEY_LAST_PLAYED, entry.lastPlayed.ToString("o", System.Globalization.CultureInfo.InvariantCulture), entry.lastPlayed.ToString(), lastPlayedWinTime));

                    // Write the tag
                    WriteCustomTag(file, Consts.TAG_LAST_PLAYED, lastPlayedWinTime.ToString(), ds);
                }

                // Play Count
                if (!args.skipPlayCount && entry.playCount > 0)
                {
                    if (Settings.Current.fullLogging)
                        ds.Log(string.Format("\tWriting {0}: {1}", Consts.PLIST_KEY_PLAY_COUNT, entry.playCount));

                    // Write the tag
                    WriteCustomTag(file, Consts.TAG_PLAY_COUNT, entry.playCount.ToString(), ds);
                }

                // Rating
                if (!args.skipRating && entry.rating != Rating.Unrated)
                {
                    int ratingInStars = (int)entry.rating;

                    if (Settings.Current.fullLogging)
                        ds.Log(string.Format("\tWriting {0}: {1} ({2} stars)", Consts.PLIST_KEY_RATING, ratingInStars * 20, ratingInStars));

                    // Write the tag
                    WriteRating(file, ratingInStars, ds);
                }

                entry.wroteTags = true;
            }

            // Write the modified tags to the file
            try
            {
                if (Settings.Current.dontAddID3v1 || Settings.Current.removeID3v1)
                {
                    // Remove the ID3v1 tag from the tags-to-write
                    // if the file on disk doesn't have an ID3v1 tag (or if we're forcibly removing it)
                    if (Settings.Current.removeID3v1 || file.TagTypesOnDisk.HasFlag(TagTypes.Id3v1) == false)
                        file.RemoveTags(TagTypes.Id3v1);
                }

                file.Save();

                // If we're here, it means the TagLib.File was saved correctly

                if (isRetry)
                {
                    ds.LogSuccess("\tReattempt succeeded");
                }
            }
            catch (IOException ioex)
            {
                if (isRetry)
                {
                    ds.LogError("\tCould not save file after retry, exception: " + ioex.Message);
                    return TagWriterReturnCode.IOEError;
                }
                else
                {
                    ds.LogError("\t-> An IO exception occured while saving tags to the file \"" + entry.fileName + "\"");

                    // Get the locking processes (if any)
                    var lockingProcesses = FileLockUtility.GetProcessesLockingFile(entry.mappedFilePath);

                    // Print the process(es) that are locking the file
                    if (lockingProcesses != null && lockingProcesses.Count > 0)
                    {
                        ds.LogError("\tThe file appears to be locked by the process: " +
                            string.Join(", ", lockingProcesses.Select(p => p.ProcessName).ToArray()));
                        return TagWriterReturnCode.IOEError;
                    }

                    // Otherwise if there is no locking process, this is a known issue in TagLib while using ReadStyle.PictureLazy.
                    // Reattempt, using the default ReadStyle.Average
                    else
                    {
                        ds.LogError("\t-> Reattempting load with different parameters...");
                        isRetry = true;
                        goto Retry;
                    }
                }
            }
            catch (Exception ex)
            {
                ds.LogError("An error occurred while saving tags to \"" + entry.fileName + "\": (" + ex.Message + ")");
                return TagWriterReturnCode.OtherError;
            }

            file.Dispose();

            return TagWriterReturnCode.Success;
        }

        // --- TagLib Methods ---

        // Write custom, non-standard key-value pair to tags
        public static void WriteCustomTag(TagLib.File file, string key, string value, DebugStack ds)
        {
            // Write ID3v2 TXXX Frame for MP3/AAC/AIFF
            if (file.TagTypes.HasFlag(TagTypes.Id3v2))
            {
                var tag = (TagLib.Id3v2.Tag)file.GetTag(TagTypes.Id3v2, true);
                var textframe = TagLib.Id3v2.UserTextInformationFrame.Get(tag, key, StringType.UTF16, true);
                textframe.Text = new string[] { value };

                if (Settings.Current.fullLogging)
                    ds.Log("\t-> Wrote ID3V2 TXXX Frame: key=\"" + key + "\", value=\"" + value + "\"");
            }

            // Write AppleTag AppleAnnotationBox for ALAC/MPEG4
            else if (file.TagTypes.HasFlag(TagTypes.Apple))
            {
                var tag = (TagLib.Mpeg4.AppleTag)file.GetTag(TagTypes.Apple, false);

                // Check to see if we don't already have a DashBox with this key, and if we do - remove it (this format allows multiple DashBoxes with the same key)
                if (tag.GetDashBox(Consts.APPLE_TAG_MEANSTRING, key) != null)
                    RemoveCustomTag(file, key, ds);

                // AppleAdditionalInfoBoxes prepend the data with 4 null characters for some reason, so hey lets do the same! I'm sure it's for a good cause
                tag.SetDashBox(Consts.APPLE_TAG_PREFIX + Consts.APPLE_TAG_MEANSTRING,
                               Consts.APPLE_TAG_PREFIX + key,
                               value.ToString());

                if (Settings.Current.fullLogging)
                    ds.Log("\t-> Wrote AppleAnnotationBox tag: key=\"" + key + "\", value=\"" + value + "\"");
            }

            // Write XiphComment field for FLAC
            else if (file.TagTypes.HasFlag(TagTypes.FlacMetadata))
            {
                var tag = (TagLib.Ogg.XiphComment)file.GetTag(TagTypes.Xiph);
                tag.SetField(key, new string[] { value });

                if (Settings.Current.fullLogging)
                    ds.Log("\t-> Wrote Ogg.XiphComment: key=\"" + key + "\", value=\"" + value + "\"");
            }

            else
            {
                ds.LogWarning("\t-> Could not write data. Unsupported or missing tag type!");
            }
        }

        // Removes a custom tag with <key> from <file>. Returns true if a tag was found and removed
        public static bool RemoveCustomTag(TagLib.File file, string key, DebugStack ds)
        {
            // Remove ID3v2 TXXX Frame for MP3/AAC/AIFF
            if (file.TagTypes.HasFlag(TagTypes.Id3v2))
            {
                var tag = (TagLib.Id3v2.Tag)file.GetTag(TagTypes.Id3v2, true);
                var textFrame = TagLib.Id3v2.UserTextInformationFrame.Get(tag, key, StringType.UTF16, false);

                if (textFrame != null)
                {
                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> Removed ID3V2 TXXX Frame with the key \"" + key + "\"");

                    tag.RemoveFrame(textFrame);
                    return true;
                }
                else
                {
                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> An ID3V2 TXXX Frame with the key \"" + key + "\" was not present");

                    return false;
                }
            }

            // Remove AppleTag AppleAnnotationBox for ALAC/MPEG4
            else if (file.TagTypes.HasFlag(TagTypes.Apple))
            {
                var tag = (TagLib.Mpeg4.AppleTag)file.GetTag(TagTypes.Apple, false);

                // Only remove if there is something to remove
                if (tag.GetDashBox(Consts.APPLE_TAG_MEANSTRING, key) != null)
                {
                    // We have to loop until the DashBox is no longer present, since MP4 tags support multiple
                    // tagboxes with the same key, and the user may have written to the file more than once
                    while (tag.GetDashBox(Consts.APPLE_TAG_MEANSTRING, key) != null)
                    {
                        if (Settings.Current.fullLogging)
                            ds.Log("\t-> Removed AppleAnnotationBox with the key \"" + key + "\"");

                        // Setting the DashBox to an empty string will remove it. For some reason we don't need to include 4 null characters when removing
                        tag.SetDashBox(Consts.APPLE_TAG_MEANSTRING, key, string.Empty);
                    }

                    return true;
                }
                else
                {
                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> An AppleAnnotationBox with the key \"" + key + "\" was not present");

                    return false;
                }
            }

            // Write XiphComment field for FLAC
            else if (file.TagTypes.HasFlag(TagTypes.FlacMetadata))
            {
                var tag = (TagLib.Ogg.XiphComment)file.GetTag(TagTypes.Xiph);

                if (tag.GetField(key) != null)
                {
                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> Removed XiphComment with the key \"" + key + "\"");

                    tag.RemoveField(key);
                    return true;
                }
                else
                {
                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> A XiphComment with the key \"" + key + "\" was not present");

                    return false;
                }
            }
            else
            {
                ds.LogWarning("\t-> Could not remove data. Unsupported or missing tag type!");
            }

            return false;
        }

        // Write rating to tags using Rating enum
        public static void WriteRating(TagLib.File file, Rating rating, DebugStack ds)
        {
            // Do not write if rating is unrated
            if (rating == Rating.Unrated)
            {
                if (Settings.Current.fullLogging)
                    ds.Log("\t-> Rating not written, since the entry was unrated");

                return;
            }
            else
                WriteRating(file, (int)rating, ds);
        }

        // Write rating to tags using a star rating
        public static void WriteRating(TagLib.File file, int starRating, DebugStack ds)
        {
            // Write Id3v2 POPM frame
            // See https://en.wikipedia.org/wiki/ID3#ID3v2_rating_tag_issue
            if (file.TagTypes.HasFlag(TagTypes.Id3v2))
            {
                var tag = (TagLib.Id3v2.Tag)file.GetTag(TagTypes.Id3v2, true);
                var popmFrame = TagLib.Id3v2.PopularimeterFrame.Get(tag, Consts.ID3_POPM_USER, true);

                switch (starRating)
                {
                    case 1: popmFrame.Rating = Consts.ID3_POPM_RATING_1; break;
                    case 2: popmFrame.Rating = Consts.ID3_POPM_RATING_2; break;
                    case 3: popmFrame.Rating = Consts.ID3_POPM_RATING_3; break;
                    case 4: popmFrame.Rating = Consts.ID3_POPM_RATING_4; break;
                    case 5: popmFrame.Rating = Consts.ID3_POPM_RATING_5; break;
                    default:
                    {
                        ds.LogWarning("\t-> Invalid rating of " + starRating + " (" + (starRating * 20) + "). Skipping write...");
                        popmFrame = null;
                        break;
                    }
                }

                if (Settings.Current.fullLogging && popmFrame != null)
                    ds.Log("\t-> Wrote ID3V2 Popularimeter (POMP) frame: value: " + popmFrame.Rating + " (" + starRating + " stars)");
            }

            // Apple uses a regular text field, with a 1-5 value
            // FLAC uses a regular vorbis comment, with a 1-5 value
            else if (file.TagTypes.HasFlag(TagTypes.Apple) || file.TagTypes.HasFlag(TagTypes.Xiph))
            {
                WriteCustomTag(file, Consts.TAG_RATING, starRating.ToString(), ds);
            }
        }

        public static void RemoveRating(TagLib.File file, DebugStack ds)
        {
            // Remove Id3v2 POPM frame
            if (file.TagTypes.HasFlag(TagTypes.Id3v2))
            {
                var tag = (TagLib.Id3v2.Tag)file.GetTag(TagTypes.Id3v2, true);
                var popmFrame = TagLib.Id3v2.PopularimeterFrame.Get(tag, Consts.ID3_POPM_USER, false);

                if (popmFrame != null)
                {
                    tag.RemoveFrame(popmFrame);

                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> Removed ID3V2 Popularimeter (POMP) frame");
                }
                else
                {
                    if (Settings.Current.fullLogging)
                        ds.Log("\t-> An ID3V2 Popularimeter (POMP) frame was not present, so it was not removed");
                }
            }

            // For all other fields, use custom rating field
            else if (file.TagTypes.HasFlag(TagTypes.Apple) || file.TagTypes.HasFlag(TagTypes.Xiph))
            {
                RemoveCustomTag(file, Consts.TAG_RATING, ds);
            }
        }
    }
}
